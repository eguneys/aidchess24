import{I as C,f as P,n as h,r as N,v as I,u as Y,i as d,c as _,S as j,h as M,j as A,F as q,t as g,a as m,q as v}from"./index-XVCA7pQm.js";import{S as D,C as F}from"./Chessboard-MLe-dbZ0.js";import{T as L,C as R,c as E}from"./Chesstree2-9apf-j-g.js";var W=g("<div class=sixth><div class=board-wrap></div><div class=replay-wrap><div class=replay-header><h2 class=eval-title> +0.2 </h2></div><div class=replay><div class=replay-v></div><div class=tools></div></div></div><div class=howto><h1> Sixth Game </h1><h2> How to Play </h2><ul><li><p>You play an analysis game against the engine.</p></li><li><p>You play both white and black, Then it's your turn.</p></li><li><p>You have 6 plies to play. You can play any line you like.</p></li><li><p>Then it's engine's turn. It also has 6 plies.</p></li><li><p>Engine will analyse your lines, and prefer to keep your accurate moves, and surely drop your inaccurate moves, and make a new move for each dropped move.</p></li><li><p>Each accurate move you get a point. 4, 5 or 6 accurate moves you get bonus points. No accurate moves game ends.</p></li><li><p>You can use your plies either as separate lines or a single line, whichever you feel is comfortable for you.</p></li><li><p>Essentially you can be playing at most 6 games at once, against the engine.</p></li><li><p class=underline>When an inaccurate move drops, it will automatically drop next moves that comes after it if there is any. So if you rely on a single line, and first move fails, game ends.</p></li></ul><br></div><div class=under><br><div class=howto><h2> Considerations </h2><ul><li>Two player real time adaptation.</li><li>Player doesn't choose a color. Essentially player will try to find a drawing line without blundering for both sides. This might come as easy, just exchanging pieces willingly might put you in a situation.</li><li>To make things interesting and combat this, engine might have a temper that doesn't so much prefer your moves but picks other random but accurate moves adding more diversity to the game.</li><li>Occasionaly, user might want to show a losing line, by indicating the played move as a blunder and give a continuation. This might be incentivized somehow. Similarly user might want to indicate a line as a forcing line, like if a move is the only best move available.</li></ul><br>"),G=g("<div class=sixth-path>"),O=g("<span><span class=index>"),z=g("<span>");class u{_populated_node;get populated_node(){return this._populated_node[0]()}set populated_node(e){this._populated_node[1](e)}_node;get node(){return this._node[0]()}set node(e){this._node[1](e)}_eval_accuracy;set accuracy(e){this._eval_accuracy[1](e)}get accuracy(){return this._eval_accuracy[0]()}get is_empty(){return this.node===void 0}get is_analysed(){return this.accuracy!==void 0}get is_keep(){return this.accuracy&&this.accuracy.accuracy>70}get is_dropped(){return this.is_analysed&&!this.is_keep}_is_predropped;get is_predropped(){return this._is_predropped[0]()}set is_predropped(e){this._is_predropped[1](e)}get is_populated(){return this.populated_node!==void 0}get status_klass(){let e=["status"];return this.is_populated&&e.push("populated"),this.is_predropped?e.push("predrop"):this.is_analysed?(this.is_keep&&e.push("keep"),this.is_dropped&&e.push("drop")):e.push("played"),e.join(" ")}get status(){if(this.is_populated)return"populated.";if(this.is_predropped)return"pre-dropped.";if(this.is_analysed){if(this.is_keep)return"kept.";if(this.is_dropped)return"dropped."}else return"played."}constructor(){this._populated_node=m(),this._node=m(),this._eval_accuracy=m(),this._is_predropped=m(!1)}}const U=()=>{let n=new D;const e=new L(C),l=[new u,new u,new u,new u,new u,new u],y=P(()=>l.find(t=>t.is_empty));h(v(()=>n.add_uci,t=>{if(!t)return;let[i]=t,a=y();if(a){let s=e.add_uci(i);a.node=e.tree.get_at(s)}})),h(v(y,(t,i)=>{!t&&i&&$().then(()=>new Promise(a=>setTimeout(a,1e3))).then(a=>{e.drop_failed_paths()}).then(()=>new Promise(a=>setTimeout(a,1e3))).then(()=>k()).then(()=>{l.forEach(a=>{a.populated_node=void 0,a.node=void 0,a.accuracy=void 0,a.is_predropped=!1})})}));async function k(){const t=l.find(r=>!r.is_populated&&(r.is_predropped||r.is_dropped));if(!t)return;let i=l.filter(r=>r.is_populated).map(r=>r.populated_node.path);i.push(...e.tree.all_leaves.map(r=>r.path));let a=await e.tree.request_ceval_and_get_at(E(i)),s=e.tree.get_children(a.path),w=a.eval_accuracy.multi_pvs4.filter(r=>!s.some(o=>o.uci===r)),c=E(w);e.cursor_path=a.path,e.add_and_reveal_uci(c),t.populated_node=e.tree.get_at(e.cursor_path),await new Promise(r=>setTimeout(r,1e3)),await k()}async function $(){const t=l.find(s=>!s.is_predropped&&!s.is_analysed);if(!t)return;const i=await e.tree.request_ceval_and_get_at(t.node.path),a=i.eval_accuracy;t.accuracy=a,t.is_keep?e._solved_paths.add_path(i.path):(e.add_failed_path(i.path),l.filter(s=>s!==t&&s.node.path.join("").startsWith(i.path.join(""))).forEach(s=>s.is_predropped=!0)),await new Promise(s=>setTimeout(s,1e3)),await $()}h(v(()=>e.fen_last_move,t=>{if(t){let[i,a]=t;n.on_set_fen_uci(i,a)}else n.on_set_fen_uci(C)})),h(v(()=>n.on_wheel,t=>{t&&e.on_wheel(t)}));const S=t=>{const i=t.target;i.tagName!=="PIECE"&&i.tagName!=="SQUARE"&&i.tagName!=="CG-BOARD"||(t.preventDefault(),n.set_on_wheel(Math.sign(t.deltaY)))};let f;return N(()=>{f.addEventListener("wheel",S,{passive:!1})}),I(()=>{f.removeEventListener("wheel",S)}),(()=>{var t=W(),i=t.firstChild,a=i.nextSibling,s=a.firstChild,w=s.nextSibling,c=w.firstChild,r=c.nextSibling;return Y(o=>f=o,t),d(i,_(F,{get movable(){return y()!==void 0},get doPromotion(){return n.promotion},get onMoveAfter(){return n.on_move_after},get fen_uci(){return n.fen_uci},get color(){return n.turnColor},get dests(){return n.dests}})),d(c,_(R,{lala:e})),d(r,_(q,{each:l,children:o=>(()=>{var x=G();return d(x,_(j,{get when(){return o.node},get fallback(){return"--"},children:b=>[(()=>{var p=O(),T=p.firstChild;return d(T,()=>`${Math.ceil(b().ply/2)}${b().ply%2===0?"... ":". "}`),d(p,()=>b().san,null),p})(),(()=>{var p=z();return d(p,()=>o.status),M(()=>A(p,o.status_klass)),p})()]})),x})()})),t})()};export{U as default};
