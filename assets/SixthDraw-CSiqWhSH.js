var M=Object.defineProperty;var N=(a,e,n)=>e in a?M(a,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):a[e]=n;var c=(a,e,n)=>(N(a,typeof e!="symbol"?e+"":e,n),n);import{b as I,l as _,o as m,p as Y,n as j,q as A,i as d,c as v,S as q,f as D,g as F,F as L,t as g,k as f}from"./index-P72p3OdZ.js";import{I as E}from"./chess_pgn_logic-BSdhjn1D.js";import{S as R,C as W}from"./Shalala-D-bXqfRk.js";import{T as G,C as O}from"./Chesstree2-DLgdXuAQ.js";const z=(a=1)=>()=>{var e=Math.sin(a++)*1e4;return e-Math.floor(e)},B=z();function H(a,e=B){return Math.floor(e()*a)}function T(a){return a[H(a.length)]}var Q=g("<div class=sixth><div class=board-wrap></div><div class=replay-wrap><div class=replay-header><h2 class=eval-title> +0.2 </h2></div><div class=replay><div class=replay-v></div><div class=tools></div></div></div><div class=howto><h1> Sixth Game </h1><h2> How to Play </h2><ul><li><p>You play an analysis game against the engine.</p></li><li><p>You play both white and black, Then it's your turn.</p></li><li><p>You have 6 plies to play. You can play any line you like.</p></li><li><p>Then it's engine's turn. It also has 6 plies.</p></li><li><p>Engine will analyse your lines, and prefer to keep your accurate moves, and surely drop your inaccurate moves, and make a new move for each dropped move.</p></li><li><p>Each accurate move you get a point. 4, 5 or 6 accurate moves you get bonus points. No accurate moves game ends.</p></li><li><p>You can use your plies either as separate lines or a single line, whichever you feel is comfortable for you.</p></li><li><p>Essentially you can be playing at most 6 games at once, against the engine.</p></li><li><p class=underline>When an inaccurate move drops, it will automatically drop next moves that comes after it if there is any. So if you rely on a single line, and first move fails, game ends.</p></li></ul><br></div><div class=under><br><div class=howto><h2> Considerations </h2><ul><li>Two player real time adaptation.</li><li>Player doesn't choose a color. Essentially player will try to find a drawing line without blundering for both sides. This might come as easy, just exchanging pieces willingly might put you in a situation.</li><li>To make things interesting and combat this, engine might have a temper that doesn't so much prefer your moves but picks other random but accurate moves adding more diversity to the game.</li><li>Occasionaly, user might want to show a losing line, by indicating the played move as a blunder and give a continuation. This might be incentivized somehow. Similarly user might want to indicate a line as a forcing line, like if a move is the only best move available.</li></ul><br>"),U=g("<div class=sixth-path>"),J=g("<span><span class=index>"),K=g("<span>");class u{constructor(){c(this,"_populated_node");c(this,"_node");c(this,"_eval_accuracy");c(this,"_is_predropped");this._populated_node=f(),this._node=f(),this._eval_accuracy=f(),this._is_predropped=f(!1)}get populated_node(){return this._populated_node[0]()}set populated_node(e){this._populated_node[1](e)}get node(){return this._node[0]()}set node(e){this._node[1](e)}set accuracy(e){this._eval_accuracy[1](e)}get accuracy(){return this._eval_accuracy[0]()}get is_empty(){return this.node===void 0}get is_analysed(){return this.accuracy!==void 0}get is_keep(){return this.accuracy&&this.accuracy.accuracy>70}get is_dropped(){return this.is_analysed&&!this.is_keep}get is_predropped(){return this._is_predropped[0]()}set is_predropped(e){this._is_predropped[1](e)}get is_populated(){return this.populated_node!==void 0}get status_klass(){let e=["status"];return this.is_populated&&e.push("populated"),this.is_predropped?e.push("predrop"):this.is_analysed?(this.is_keep&&e.push("keep"),this.is_dropped&&e.push("drop")):e.push("played"),e.join(" ")}get status(){if(this.is_populated)return"populated.";if(this.is_predropped)return"pre-dropped.";if(this.is_analysed){if(this.is_keep)return"kept.";if(this.is_dropped)return"dropped."}else return"played."}}const ae=()=>{let a=new R;const e=new G(E),n=[new u,new u,new u,new u,new u,new u],y=I(()=>n.find(t=>t.is_empty));_(m(()=>a.add_uci,t=>{if(!t)return;let i=y();if(i){let s=e.add_uci(t);i.node=e.tree.get_at(s)}})),_(m(y,(t,i)=>{!t&&i&&x().then(()=>new Promise(s=>setTimeout(s,1e3))).then(s=>{e.drop_failed_paths()}).then(()=>new Promise(s=>setTimeout(s,1e3))).then(()=>$()).then(()=>{n.forEach(s=>{s.populated_node=void 0,s.node=void 0,s.accuracy=void 0,s.is_predropped=!1})})}));async function $(){const t=n.find(r=>!r.is_populated&&(r.is_predropped||r.is_dropped));if(!t)return;let i=n.filter(r=>r.is_populated).map(r=>r.populated_node.path);i.push(...e.tree.all_leaves.map(r=>r.path));let s=await e.tree.request_ceval_and_get_at(T(i)),o=e.tree.get_children(s.path),b=s.eval_accuracy.multi_pvs4.filter(r=>!o.some(l=>l.uci===r)),h=T(b);e.cursor_path=s.path,e.add_and_reveal_uci(h),t.populated_node=e.tree.get_at(e.cursor_path),await new Promise(r=>setTimeout(r,1e3)),await $()}async function x(){const t=n.find(o=>!o.is_predropped&&!o.is_analysed);if(!t)return;const i=await e.tree.request_ceval_and_get_at(t.node.path),s=i.eval_accuracy;t.accuracy=s,t.is_keep?e._solved_paths.add_path(i.path):(e.add_failed_path(i.path),n.filter(o=>o!==t&&o.node.path.join("").startsWith(i.path.join(""))).forEach(o=>o.is_predropped=!0)),await new Promise(o=>setTimeout(o,1e3)),await x()}_(m(()=>e.fen_last_move,t=>{if(t){let[i,s]=t;a.on_set_fen_uci(i,s)}else a.on_set_fen_uci(E)})),_(m(()=>a.on_wheel,t=>{t&&e.on_wheel(t)}));const S=t=>{const i=t.target;i.tagName!=="PIECE"&&i.tagName!=="SQUARE"&&i.tagName!=="CG-BOARD"||(t.preventDefault(),a.set_on_wheel(Math.sign(t.deltaY)))};let w;return Y(()=>{w.addEventListener("wheel",S,{passive:!1})}),j(()=>{w.removeEventListener("wheel",S)}),(()=>{var t=Q(),i=t.firstChild,s=i.nextSibling,o=s.firstChild,b=o.nextSibling,h=b.firstChild,r=h.nextSibling;return A(l=>w=l,t),d(i,v(W,{get movable(){return y()!==void 0},get doPromotion(){return a.promotion},get onMoveAfter(){return a.on_move_after},get fen_uci(){return a.fen_uci},get color(){return a.turnColor},get dests(){return a.dests}})),d(h,v(O,{lala:e})),d(r,v(L,{each:n,children:l=>(()=>{var C=U();return d(C,v(q,{get when(){return l.node},get fallback(){return"--"},children:k=>[(()=>{var p=J(),P=p.firstChild;return d(P,()=>`${Math.ceil(k().ply/2)}${k().ply%2===0?"... ":". "}`),d(p,()=>k().san,null),p})(),(()=>{var p=K();return d(p,()=>l.status),D(()=>F(p,l.status_klass)),p})()]})),C})()})),t})()};export{ae as default};
